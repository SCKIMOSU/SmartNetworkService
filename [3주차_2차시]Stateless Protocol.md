# Stateless 프로토콜

- **요청 간에 서버가 클라이언트의 세션 상태를 보관하지 않는** 통신 방식
    - **연결-세션 비지속**
    - 각 요청은 **독립적**이고, 처리에 필요한 모든 컨텍스트(**인증**·로케일·페이로드 등)를 **그 요청 메시지 안에 포함해야 함.**
        - **무상태(stateless)** ≠ 비연결(connectionless)
        - HTTP는 TCP keep-alive로 같은 연결을 재사용할 수 있어도, **요청 처리 자체는 무상태**
    - **HTTP/1.x, HTTP/2의 기본 동작**
        - REST API 설계 원칙도 무상태를 지향
    - **Stateful**
        - WebSocket : 연결-세션 지속
        - FTP/SSH(세션 상태 유지)
- 장점
    - **수평 확장 용이**: 어떤 서버가 받아도 같은 결과 → 로드밸런싱/오토스케일 유리
    - **장애 격리·복구 쉬움**: 서버에 세션이 없어 재시작/대체가 간단
    - **캐싱 친화적**: 헤더/URL/본문만 같으면 중간 캐시가 재사용 가능(ETag, Cache-Control)
- 단점
    - 요청 크기 증가: 매 요청마다 **인증**·컨텍스트를 담아야 함
    - **서버 주도 푸시 어려움**: 상태를 들고 있지 않으니 보통 폴링/SSE/WebSocket 등 별도 메커니즘 필요
    - **순서/중복 처리**: 네트워크 재시도 시 **멱등성**을 확보해야 함(예: Idempotency-Key)
- **Stateless**는 서버가 요청 사이의 클라이언트 상태를 저장하지 않는 설계
    - 확장성과 단순성이 큰 장점이지만, 그만큼 **요청마다 모든 정보 (토큰/컨텍스트)** 설계

# Stateful 프로토콜

- 통신 세션/대화가 이어지는 동안 서버(또는 양쪽)이 **상태를 보관**하고, 이후 메시지 처리에 그 상태를 활용하는 프로토콜/설계.
    - **요청이 서로 독립적이지 않고,** 앞선 단계의 맥락(**로그인**·모드·네고 결과·커서 등)**을 서버가 기억**
    - stateful ≠ connection-oriented(연결형) 이지만, 지속 연결을 동반
        - HTTP 자체는 무상태지만 서버 세션을 쓰면 애플리케이션은 유상태
    - **WebSocket**
        - 연결·세션 유지, 양방향 메시징
    - **SSH/FTP/Telnet/SMTP/IMAP**
        - 로그인/모드/트랜잭션 상태 유지
    - **DB 프로토콜**
        - PostgreSQL/MySQL: 트랜잭션·프리페어드 스테이트
    - **HTTP + 서버 세션**
        - 쿠키로 세션 키, 서버에 상태 저장
- **장점**
    - 대화형 흐름에 **왕복(RTT) 절감**, **양방향 푸시** 쉬움
    - 로그인·협상 결과·커서 등 **컨텍스트 재사용** 가능
    - QoS/흐름제어·압축 상태 등 **세션 최적화** 가능
- **단점**
    - **수평 확장/복구 난이도↑**: 세션을 어느 인스턴스가 들고 있는가?
    - **스티키 세션** 필요하거나, **세션 저장소(예: Redis)** 도입 필요
    - **장기 연결 자원**(FD/메모리) 소모, **백프레셔**·타임아웃 관리 필수
    - 장애 시 **세션 유실/재동기** 처리 복잡
- **Stateful**은 서버가 대화 맥락을 **기억**하는 설계
    - 실시간성과 대화형 UX에 강하지만, **세션 저장·스케일링·복구**를 잘 설계해야 안정적으로 운영.

# HTTP 폴링(HTTP polling)

- 클라이언트가 **주기적으로 HTTP 요청을 보내** “새 데이터 있니?”를 묻고, 서버는 그때 그때의 **최신 상태를 응답**하는 방식.
- **클라이언트가 일정 간격으로 반복 요청**하여 서버 변화가 생겼는지 확인

---

- 종류
    - **숏 폴링(short polling)**
        - 고정 간격(예: 1초, 5초)으로 `GET /updates?since=...` 같은 요청을 계속 보냄.
        - 서버는 즉시 응답(데이터 있으면 200, 없으면 204 또는 빈 목록).
    - **롱 폴링(long polling, Comet)**
        - 요청이 오면 **데이터가 생길 때까지 서버가 응답을 보류**(타임아웃 전까지).
        - 데이터가 생기면 곧바로 응답 → 클라이언트는 즉시 **새 요청을 다시** 보냄.
        - 실시간성은 좋지만, 각 이벤트마다 **요청이 새로 생긴다**는 점은 동일.
- 폴링은 언제나 요청/응답 단발 모델
    - 연결 유지 X, 서버가 임의로 먼저 푸시 X

---

- 장점
    - **구현/배포가 단순**
        - 일반 HTTP라 프록시·로드밸런서·방화벽과 궁합이 좋음.
    - **언어/런타임 제약 적음**
        - 거의 모든 환경에서 쉽게 구현.
- 단점
    - **오버헤드**: 이벤트가 없어도 헤더·인증 포함 요청이 계속 발생 → 트래픽/CPU 낭비.
    - **지연**: 숏 폴링은 **폴링 주기만큼 늦게** 알게 됨.
    - **확장성 이슈**: 많은 클라이언트가 짧은 주기로 요청하면 서버 부하↑(thundering herd).
    - **상태 동기화 복잡도**: 중복/누락 방지를 위한 **커서/토큰** 관리가 필요.

---

- **구현/운영 단순성**이 최우선일 때.
    - 기존 인프라 제약으로 WebSocket/SSE를 쓰기 어렵거나 **임시 대안**이 필요할 때.
- 실시간성이 중요하면:
    - **SSE**(서버→클라이언트 단방향 스트림)
    - **WebSocket**(완전 양방향, 프레임 기반)
