Stateless 프로토콜
⦁	요청 간에 서버가 클라이언트의 세션 상태를 보관하지 않는 통신 방식
⦁	연결-세션 비지속
⦁	각 요청은 독립적이고, 처리에 필요한 모든 컨텍스트(인증·로케일·페이로드 등)를 그 요청 메시지 안에 포함해야 함.
⦁	무상태(stateless) ≠ 비연결(connectionless)
⦁	HTTP는 TCP keep-alive로 같은 연결을 재사용할 수 있어도, 요청 처리 자체는 무상태
⦁	HTTP/1.x, HTTP/2의 기본 동작
⦁	REST API 설계 원칙도 무상태를 지향
⦁	Stateful
⦁	WebSocket : 연결-세션 지속
⦁	FTP/SSH(세션 상태 유지)
⦁	장점
⦁	수평 확장 용이: 어떤 서버가 받아도 같은 결과 → 로드밸런싱/오토스케일 유리
⦁	장애 격리·복구 쉬움: 서버에 세션이 없어 재시작/대체가 간단
⦁	캐싱 친화적: 헤더/URL/본문만 같으면 중간 캐시가 재사용 가능(ETag, Cache-Control)
⦁	단점
⦁	요청 크기 증가: 매 요청마다 인증·컨텍스트를 담아야 함
⦁	서버 주도 푸시 어려움: 상태를 들고 있지 않으니 보통 폴링/SSE/WebSocket 등 별도 메커니즘 필요
⦁	순서/중복 처리: 네트워크 재시도 시 멱등성을 확보해야 함(예: Idempotency-Key)
⦁	Stateless는 서버가 요청 사이의 클라이언트 상태를 저장하지 않는 설계
⦁	확장성과 단순성이 큰 장점이지만, 그만큼 요청마다 모든 정보 (토큰/컨텍스트) 설계
Stateful 프로토콜
⦁	통신 세션/대화가 이어지는 동안 서버(또는 양쪽)이 상태를 보관하고, 이후 메시지 처리에 그 상태를 활용하는 프로토콜/설계.
⦁	요청이 서로 독립적이지 않고, 앞선 단계의 맥락(로그인·모드·네고 결과·커서 등)을 서버가 기억
⦁	stateful ≠ connection-oriented(연결형) 이지만, 지속 연결을 동반
⦁	HTTP 자체는 무상태지만 서버 세션을 쓰면 애플리케이션은 유상태
⦁	WebSocket
⦁	연결·세션 유지, 양방향 메시징
⦁	SSH/FTP/Telnet/SMTP/IMAP
⦁	로그인/모드/트랜잭션 상태 유지
⦁	DB 프로토콜
⦁	PostgreSQL/MySQL: 트랜잭션·프리페어드 스테이트
⦁	HTTP + 서버 세션
⦁	쿠키로 세션 키, 서버에 상태 저장
⦁	장점
⦁	대화형 흐름에 왕복(RTT) 절감, 양방향 푸시 쉬움
⦁	로그인·협상 결과·커서 등 컨텍스트 재사용 가능
⦁	QoS/흐름제어·압축 상태 등 세션 최적화 가능
⦁	단점
⦁	수평 확장/복구 난이도↑: 세션을 어느 인스턴스가 들고 있는가?
⦁	스티키 세션 필요하거나, 세션 저장소(예: Redis) 도입 필요
⦁	장기 연결 자원(FD/메모리) 소모, 백프레셔·타임아웃 관리 필수
⦁	장애 시 세션 유실/재동기 처리 복잡
⦁	Stateful은 서버가 대화 맥락을 기억하는 설계
⦁	실시간성과 대화형 UX에 강하지만, 세션 저장·스케일링·복구를 잘 설계해야 안정적으로 운영.
