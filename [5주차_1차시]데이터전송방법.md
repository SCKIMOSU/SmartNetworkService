# 5장 데이터 전송하기

## 고정 길이 데이터 전송

- 클라이언트 코드

```jsx
#include "..\..\Common.h"

char* SERVERIP = (char*)"127.0.0.1";
#define SERVERPORT 9000
#define BUFSIZE    50

int main(int argc, char* argv[])
{
	int retval;

	// 명령행 인수가 있으면 IP 주소로 사용
	if (argc > 1) SERVERIP = argv[1];

	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	// 소켓 생성
	SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock == INVALID_SOCKET) err_quit("socket()");

	// connect()
	struct sockaddr_in serveraddr;
	memset(&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	inet_pton(AF_INET, SERVERIP, &serveraddr.sin_addr);
	serveraddr.sin_port = htons(SERVERPORT);
	retval = connect(sock, (struct sockaddr*)&serveraddr, sizeof(serveraddr));
	if (retval == SOCKET_ERROR) err_quit("connect()");

	// 데이터 통신에 사용할 변수
	char buf[BUFSIZE];
	const char* testdata[] = {
		"안녕하세요",
		"반가워요",
		"오늘따라 할 이야기가 많을 것 같네요",
		"저도 그렇네요",
	};

	// 서버와 데이터 통신
	for (int i = 0; i < 4; i++) {
		// 데이터 입력(시뮬레이션)
		memset(buf, '#', sizeof(buf));
		strncpy(buf, testdata[i], strlen(testdata[i]));

		// 데이터 보내기
		retval = send(sock, buf, BUFSIZE, 0);
		if (retval == SOCKET_ERROR) {
			err_display("send()");
			break;
		}
		printf("[TCP 클라이언트] %d바이트를 보냈습니다.\n", retval);
	}

	// 소켓 닫기
	closesocket(sock);

	// 윈속 종료
	WSACleanup();
	return 0;
}

```

- 클라이언트 결과 화면

![image.png](data.png)

- 서버 코드

```jsx
#include "..\..\Common.h"

#define SERVERPORT 9000
#define BUFSIZE    50

int main(int argc, char* argv[])
{
	int retval;

	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	// 소켓 생성
	SOCKET listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (listen_sock == INVALID_SOCKET) err_quit("socket()");

	// bind()
	struct sockaddr_in serveraddr;
	memset(&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(SERVERPORT);
	retval = bind(listen_sock, (struct sockaddr*)&serveraddr, sizeof(serveraddr));
	if (retval == SOCKET_ERROR) err_quit("bind()");

	// listen()
	retval = listen(listen_sock, SOMAXCONN);
	if (retval == SOCKET_ERROR) err_quit("listen()");

	// 데이터 통신에 사용할 변수
	SOCKET client_sock;
	struct sockaddr_in clientaddr;
	int addrlen;
	char buf[BUFSIZE + 1];

	while (1) {
		// accept()
		addrlen = sizeof(clientaddr);
		client_sock = accept(listen_sock, (struct sockaddr*)&clientaddr, &addrlen);
		if (client_sock == INVALID_SOCKET) {
			err_display("accept()");
			break;
		}

		// 접속한 클라이언트 정보 출력
		char addr[INET_ADDRSTRLEN];
		inet_ntop(AF_INET, &clientaddr.sin_addr, addr, sizeof(addr));
		printf("\n[TCP 서버] 클라이언트 접속: IP 주소=%s, 포트 번호=%d\n",
			addr, ntohs(clientaddr.sin_port));

		// 클라이언트와 데이터 통신
		while (1) {
			// 데이터 받기
			retval = recv(client_sock, buf, BUFSIZE, MSG_WAITALL);
			if (retval == SOCKET_ERROR) {
				err_display("recv()");
				break;
			}
			else if (retval == 0)
				break;

			// 받은 데이터 출력
			buf[retval] = '\0';
			printf("[TCP/%s:%d] %s\n", addr, ntohs(clientaddr.sin_port), buf);
		}

		// 소켓 닫기
		closesocket(client_sock);
		printf("[TCP 서버] 클라이언트 종료: IP 주소=%s, 포트 번호=%d\n",
			addr, ntohs(clientaddr.sin_port));
	}

	// 소켓 닫기
	closesocket(listen_sock);

	// 윈속 종료
	WSACleanup();
	return 0;
}

```

- 서버 결과 화면

![image.png](data1.png)

### 고정길이 데이터 전송 장단점

- 장점
    - 컨트롤 오버헤드가 발생하지 않음
    - 동일한 클라이언트 소켓을 사용하므로,
        - TCP 3-Way Handshake, TCP 4-Way Handshake 컨트롤 오버헤드가 발생하지 않음
- 단점
    - 데이터 오버헤드가 발생함
    - 보낼 데이터의 바이트 개수 이상의 데이터 오버헤드가 발생함

## 가변 길이 데이터 전송 연습 (실습 5-2)

- send 함수 프로토타입

![image.png](data2.png)

![image.png](data3.png)

- 클라이언트 화면
    
    ![image.png](data4.png)
    

 

![socket_buffer1.jpg](socket_buffer1.jpg)

- 클라이언트 코드
    - **줄바꿈(‘\n’)만 붙여 보내는 가변 길이 방식 클라이언트**

```jsx
#include "..\..\Common.h"

char* SERVERIP = (char*)"127.0.0.1";
#define SERVERPORT 9001
#define BUFSIZE    50

int main(int argc, char* argv[])
{
	int retval;

	// 명령행 인수가 있으면 IP 주소로 사용
	if (argc > 1) SERVERIP = argv[1];

	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	// 소켓 생성
	SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock == INVALID_SOCKET) err_quit("socket()");

	// connect()
	struct sockaddr_in serveraddr;
	memset(&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	inet_pton(AF_INET, SERVERIP, &serveraddr.sin_addr);
	serveraddr.sin_port = htons(SERVERPORT);
	retval = connect(sock, (struct sockaddr*)&serveraddr, sizeof(serveraddr));
	if (retval == SOCKET_ERROR) err_quit("connect()");

	// 데이터 통신에 사용할 변수
	char buf[BUFSIZE];
	const char* testdata[] = {
		"안녕하세요",
		"반가워요",
		"오늘따라 할 이야기가 많을 것 같네요",
		"저도 그렇네요",
	};
	int len;

	// 서버와 데이터 통신
	for (int i = 0; i < 4; i++) {
		// 데이터 입력(시뮬레이션)
		len = (int)strlen(testdata[i]);
		strncpy(buf, testdata[i], len);
		buf[len++] = '\n';  // **줄바꿈(‘\n’)만 붙여 보내는 가변 길이 방식 클라이언트** 

		// 데이터 보내기
		retval = send(sock, buf, len, 0);
                       // send()함수의 리턴값 retval 은 보낸 바이트 수를 나타냄 
		if (retval == SOCKET_ERROR) {
			err_display("send()");
			break;
		}
		printf("[TCP 클라이언트] %d바이트를 보냈습니다.\n", retval);

	}

	// 소켓 닫기
	closesocket(sock);

	// 윈속 종료
	WSACleanup();
	return 0;
}

```

- 가변 길이 서버 코드
    - **포트 9001**에서 **개행 문자(‘\n’)로 끝나는 라인 단위 프로토콜**을 수신하는 구조
    - 클라이언트는 각 메시지 끝에 반드시 `'\n'`을 붙여서 보내야 하고, 서버는 `recvline()`으로 한 줄씩 읽어 출력.

```jsx
#include "..\Common.h"

#define SERVERPORT 9001
#define BUFSIZE    512

// 내부 구현용 함수
int _recv_ahead(SOCKET s, char* p)
{
	__declspec(thread) static int nbytes = 0;
	__declspec(thread) static char buf[1024];
	__declspec(thread) static char* ptr;

	if (nbytes == 0 || nbytes == SOCKET_ERROR) {
		nbytes = recv(s, buf, sizeof(buf), 0);
		if (nbytes == SOCKET_ERROR) {
			return SOCKET_ERROR;
		}
		else if (nbytes == 0)
			return 0;
		ptr = buf;
	}

	--nbytes;
	*p = *ptr++;
	return 1;
}

// 사용자 정의 데이터 수신 함수
int recvline(SOCKET s, char* buf, int maxlen)
{
	int n, nbytes;
	char c, * ptr = buf;

	for (n = 1; n < maxlen; n++) {
		nbytes = _recv_ahead(s, &c);
		if (nbytes == 1) {
			*ptr++ = c;
			if (c == '\n')  **// 클라이언트는 각 메시지 끝에 반드시 '\n'을 붙여서 보내야 하고, 
			서버는 recvline()으로 한 줄씩 읽어 출력.**
				break;
		}
		else if (nbytes == 0) {
			*ptr = 0;
			return n - 1;
		}
		else
			return SOCKET_ERROR;
	}

	*ptr = 0;
	return n;
}

int main(int argc, char* argv[])
{
	int retval;

	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	// 소켓 생성
	SOCKET listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (listen_sock == INVALID_SOCKET) err_quit("socket()");

	// bind()
	struct sockaddr_in serveraddr;
	memset(&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(SERVERPORT);
	retval = bind(listen_sock, (struct sockaddr*)&serveraddr, sizeof(serveraddr));
	if (retval == SOCKET_ERROR) err_quit("bind()");

	// listen()
	retval = listen(listen_sock, SOMAXCONN);
	if (retval == SOCKET_ERROR) err_quit("listen()");

	// 데이터 통신에 사용할 변수
	SOCKET client_sock;
	struct sockaddr_in clientaddr;
	int addrlen;
	char buf[BUFSIZE + 1];

	while (1) {
		// accept()
		addrlen = sizeof(clientaddr);
		client_sock = accept(listen_sock, (struct sockaddr*)&clientaddr, &addrlen);
		if (client_sock == INVALID_SOCKET) {
			err_display("accept()");
			break;
		}

		// 접속한 클라이언트 정보 출력
		char addr[INET_ADDRSTRLEN];
		inet_ntop(AF_INET, &clientaddr.sin_addr, addr, sizeof(addr));
		printf("\n[TCP 서버] 클라이언트 접속: IP 주소=%s, 포트 번호=%d\n",
			addr, ntohs(clientaddr.sin_port));

		// 클라이언트와 데이터 통신
		while (1) {
			// 데이터 받기
			retval = recvline(client_sock, buf, BUFSIZE + 1);
			if (retval == SOCKET_ERROR) {
				err_display("recv()");
				break;
			}
			else if (retval == 0)
				break;

			// 받은 데이터 출력
			printf("[TCP/%s:%d] %s", addr, ntohs(clientaddr.sin_port), buf);
		}

		// 소켓 닫기
		closesocket(client_sock);
		printf("[TCP 서버] 클라이언트 종료: IP 주소=%s, 포트 번호=%d\n",
			addr, ntohs(clientaddr.sin_port));
	}

	// 소켓 닫기
	closesocket(listen_sock);

	// 윈속 종료
	WSACleanup();
	return 0;
}

```

- 서버 화면

![image.png](data5.png)

# `_recv_ahead`

```c
int _recv_ahead(SOCKET s, char* p)
{
    __declspec(thread) static int nbytes = 0;
    __declspec(thread) static char buf[1024];
    __declspec(thread) static char* ptr;

    if (nbytes == 0 || nbytes == SOCKET_ERROR) {
        **nbytes = recv(s, buf, sizeof(buf), 0);**
        if (**nbytes == SOCKET_ERROR**) {
            return SOCKET_ERROR;
        }
        else if (**nbytes == 0**)
            return 0;  // **연결 종료(상대방이 FIN 보냄)**
        **ptr = buf;**
    }

    --nbytes;
    *p = *ptr++;
    return 1;
}

```

- `recv()`는 커널 소켓 버퍼에서 데이터를 가져옴
    - 호출할 때마다 **시스템 콜 비용**이 발생하므로 비효율적.
- `_recv_ahead`는 **미리 1024바이트를 `recv()`로 읽어두고, 그 안에서 한 글자씩 꺼내주는 역할**
    - `getc()` 같은 버퍼링된 입출력 함수와 유사한 구조.
- `__declspec(thread)`
    - 스레드 로컬 저장소(TLS) : 각 스레드마다 `nbytes`, `buf`, `ptr`를 별도로 유지.
    - `nbytes`가 0이면 새로운 데이터를 `recv()`로 채움.
    - 그 후 `ptr`이 가리키는 문자를 하나 꺼내고 `nbytes--`.
- 결과:
    - **nbytes =** `1` → 정상적으로 한 글자를 읽음.
    - **nbytes =** `0` → 상대방이 연결 종료.
    - **nbytes =**`SOCKET_ERROR` → 에러 발생.

---

## `*p = *ptr++;`

```c
*p = *ptr++;

```

- `ptr++` : **후위 증가 연산자**
    - 현재 `ptr` 값을 먼저 사용하고, 그 후에 1 증가시킴.
    - (dereference) 연산자가 `++`보다 우선순위가 낮음
        - `(ptr++)`로 해석
    - 즉, 현재 `ptr`이 가리키는 값을 꺼낸 뒤, `ptr`을 다음 주소로 이동.
    - `*ptr++` = "`ptr`이 가리키는 값 하나를 읽고, `ptr`을 다음 칸으로 이동".

---

- `p = ...`
    - 호출자가 넘겨준 포인터 `p`가 가리키는 위치에 값을 저장.
- **`ptr`이 가리키던 문자를 `p` 위치에 저장하고, `ptr`은 다음 문자로 한 칸 이동**

---

- 버퍼 상태:

```
buf: [H][E][L][L][O]
ptr → buf[0] (즉, 'H')

```

- 실행:

```c
*p = *ptr++;

```

1. `ptr` = 'H'
2. 그 값을 `p`에 저장
3. `ptr++` : 이제 `ptr`은 buf[1](https://chatgpt.com/g/g-p-6860a62eee108191ab34e3550d6044dd-seumateuneteuweokeuseobiseu/c/'E')를 가리킴

---

```c
*p = *ptr;   // ptr이 가리키는 값 저장
ptr = ptr + 1; // ptr 한 칸 앞으로 이동

```

`*p = *ptr++;`는 **한 글자를 복사하고, 읽기 포인터를 다음 글자로 이동**

---

- `ptr++` = `(ptr++)`
    - 현재 글자 꺼내고, 포인터는 다음 위치로 이동.
- `p = *ptr++;`
    - 현재 글자를 `p` 위치에 저장하고, 포인터 이동.
- `_recv_ahead`는 한 글자씩 안전하게 호출자에게 넘겨주면서 내부 포인터를 진척

---

# 사용자 정의 데이터 수신 함수: `recvline`

```c
int recvline(SOCKET s, char* buf, int maxlen)
{
    int n, nbytes;
    char c, *ptr = buf;

    for (n = 1; n < maxlen; n++) {
        nbytes = _recv_ahead(s, &c);
        if (nbytes == 1) {
            *ptr++ = c;
            if (c == '\n')  // 줄바꿈 문자 나오면 한 줄 끝
                break;
        }
        else if (nbytes == 0) {
            *ptr = 0;       // 문자열 종료
            return n - 1;   // EOF 직전까지 읽은 길이 반환
        }
        else
            return SOCKET_ERROR;
    }

    *ptr = 0;  // 문자열 종료
    return n;  // 읽은 바이트 수 반환
}

```

- `_recv_ahead()`를 이용해서 **한 글자씩 읽으면서 `buf`에 채워 넣음**.
- 최대 `maxlen - 1` 글자까지만 읽어 안전하게 문자열 종료문자(`\0`) 보장.
- `\n` 문자를 만나면 루프 종료
    - 즉, “한 줄 단위”로 입력을 처리.
- 반환값:
    - `n` : 읽은 글자 수 (`\n` 포함)
    - `n-1` : EOF 도달 시 마지막에 읽은 글자 수
    - `SOCKET_ERROR` : 에러 발생

---

- `_recv_ahead()`는 소켓에서 데이터를 1바이트 단위로 꺼낼 수 있도록 버퍼링 처리.
- `recvline()`은 `_recv_ahead()`를 반복 호출하여 `\n`이 나올 때까지 읽어옴.
- **클라이언트가 `\n`으로 끝나는 메시지를 보내면 서버는 정확히 한 줄 단위로 수신**할 수 있음.

---

- 매번 `recv()` 호출하지 않고 버퍼링 → 효율적.
- 한 줄씩 깔끔하게 잘라서 처리 가능.
- 텍스트 기반 프로토콜(예: 채팅, 간단한 명령어 통신)에 적합.

---

- `_recv_ahead()` = **한 글자씩 안전하게 꺼내기 위한 버퍼링 도우미**
- `recvline()` = **개행 문자(`\n`)를 기준으로 한 줄 단위 읽기 함수**

---

### 가변길이 데이터 전송 장단점

- 장점 : 데이터 오버헤드가 발생하지 않음
    - 보낼 데이터의 바이트 개수 이상의 데이터 오버헤드가 발생하지 않음
    - 동일한 클라이언트 소켓을 사용하므로, TCP 3-Way Handshake, TCP 4-Way Handshake 컨트롤 오버헤드가 발생하지 않음
- 단점 : 데이터 오버헤드가 발생함
    - recv() API 함수의 재사용성이 떨어짐
    - recv() API 함수 이외에 수신 데이터 바이트 전송을 위한 추가적인 API 함수(recv_line()과 recv_ahead() 함수 등)를 필요로 하는 개발 비용 증가

## 고정길이+가변길이 데이터 전송  (실습 5-3)

 

- TCPServer_FixedVariable
    - 서버는 두개의 recv() 함수 사용
- 서버 코드

```jsx

#include "..\..\Common.h"

#define SERVERPORT 9000
#define BUFSIZE    512

int main(int argc, char* argv[])
{
	int retval;

	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	// 소켓 생성
	SOCKET listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (listen_sock == INVALID_SOCKET) err_quit("socket()");

	// bind()
	struct sockaddr_in serveraddr;
	memset(&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(SERVERPORT);
	retval = bind(listen_sock, (struct sockaddr*)&serveraddr, sizeof(serveraddr));
	if (retval == SOCKET_ERROR) err_quit("bind()");

	// listen()
	retval = listen(listen_sock, SOMAXCONN);
	if (retval == SOCKET_ERROR) err_quit("listen()");

	// 데이터 통신에 사용할 변수
	SOCKET client_sock;
	struct sockaddr_in clientaddr;
	int addrlen;
	int len; // 고정 길이 데이터
	char buf[BUFSIZE + 1]; // 가변 길이 데이터

	while (1) {
		// accept()
		addrlen = sizeof(clientaddr);
		client_sock = accept(listen_sock, (struct sockaddr*)&clientaddr, &addrlen);
		if (client_sock == INVALID_SOCKET) {
			err_display("accept()");
			break;
		}

		// 접속한 클라이언트 정보 출력
		char addr[INET_ADDRSTRLEN];
		inet_ntop(AF_INET, &clientaddr.sin_addr, addr, sizeof(addr));
		printf("\n[TCP 서버] 클라이언트 접속: IP 주소=%s, 포트 번호=%d\n",
			addr, ntohs(clientaddr.sin_port));

		// 클라이언트와 데이터 통신
		while (1) {
			// 데이터 받기(고정 길이)
			retval = recv(client_sock, (char*)&len, sizeof(int), MSG_WAITALL);
			if (retval == SOCKET_ERROR) {
				err_display("recv()");
				break;
			}
			else if (retval == 0)
				break;

			// 데이터 받기(가변 길이)
			retval = recv(client_sock, buf, len, MSG_WAITALL);
			if (retval == SOCKET_ERROR) {
				err_display("recv()");
				break;
			}
			else if (retval == 0)
				break;

			// 받은 데이터 출력
			buf[retval] = '\0';
			printf("[TCP/%s:%d] %s\n", addr, ntohs(clientaddr.sin_port), buf);
		}

		// 소켓 닫기
		closesocket(client_sock);
		printf("[TCP 서버] 클라이언트 종료: IP 주소=%s, 포트 번호=%d\n",
			addr, ntohs(clientaddr.sin_port));
	}

	// 소켓 닫기
	closesocket(listen_sock);

	// 윈속 종료
	WSACleanup();
	return 0;
}

```

- 서버 화면

![image.png](data6.png)

- TCPClient_FixedVariable
    - 클라이언트는 두 개의 send() 함수 사용

- 클라이언트 코드

```jsx
#include "..\..\Common.h"

char* SERVERIP = (char*)"127.0.0.1";
#define SERVERPORT 9000
#define BUFSIZE    50

int main(int argc, char* argv[])
{
	int retval;

	// 명령행 인수가 있으면 IP 주소로 사용
	if (argc > 1) SERVERIP = argv[1];

	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	// 소켓 생성
	SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock == INVALID_SOCKET) err_quit("socket()");

	// connect()
	struct sockaddr_in serveraddr;
	memset(&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	inet_pton(AF_INET, SERVERIP, &serveraddr.sin_addr);
	serveraddr.sin_port = htons(SERVERPORT);
	retval = connect(sock, (struct sockaddr*)&serveraddr, sizeof(serveraddr));
	if (retval == SOCKET_ERROR) err_quit("connect()");

	// 데이터 통신에 사용할 변수
	char buf[BUFSIZE];
	const char* testdata[] = {
		"안녕하세요",
		"반가워요",
		"오늘따라 할 이야기가 많을 것 같네요",
		"저도 그렇네요",
	};
	int len;

	// 서버와 데이터 통신
	for (int i = 0; i < 4; i++) {
		// 데이터 입력(시뮬레이션)
		len = (int)strlen(testdata[i]);
		printf("[데이터 입력(시뮬레이션)] 내용= %s len(길이)= %d바이트 \n", testdata[i], len);
		strncpy(buf, testdata[i], len);

		// 데이터 보내기(고정 길이)
		retval = send(sock, (char*)&len, sizeof(int), 0);
                       // len 주소에 있는 내용을 sock을 통해 sizeof(int) 길이만큼 send
		// 1. sock : 통신할 대상(서버)과 연결된 소켓 
		// 2. &len : 보낼 데이터를 담고 있는 응용 프로그램의 버퍼의 주소
		// 3. len : 보낼 데이터의 크기 

		printf("retval (데이터 보내기(고정 길이))= %d 바이트 \n", (int)sizeof(int) ); //*((char*)&len)

		if (retval == SOCKET_ERROR) {
			err_display("send()");
			break;
		}

		// 데이터 보내기(가변 길이)
		retval = send(sock, buf, len, 0);
                       // buf 주소에 있는 내용을 sock을 통해 len 길이만큼 send 
		printf("retval (데이터 보내기(가변 길이))= %d 바이트 \n", len);

		if (retval == SOCKET_ERROR) {
			err_display("send()");
			break;
		}
		printf("[TCP 클라이언트] %d+%d바이트를 "
			"보냈습니다.\n", (int)sizeof(int), retval);
	}

	// 소켓 닫기
	closesocket(sock);

	// 윈속 종료
	WSACleanup();
	return 0;
}

```

- 클라이언트 화면

![image.png](data7.png)

### 고정길이+가변길이 데이터 전송 장단점

- 장점 : 컨트롤 오버헤드가 발생하지 않음
    - send() 함수를 두 번 사용하지만,
    - 동일한 클라이언트 소켓을 사용하므로,
    - TCP 3-Way Handshake, TCP 4-Way Handshake 컨트롤 오버헤드가 발생하지 않음
- 단점 : 데이터 오버헤드가 발생함
    - 보낼 데이터의 바이트 개수 이상의 데이터 오버헤드가 발생함

## 데이터 전송 후 종료

- 클라이언트 코드 : **TCPClient_CloseOnTransfer**

```jsx
#include "..\..\Common.h"

char* SERVERIP = (char*)"127.0.0.1";
#define SERVERPORT 9000
#define BUFSIZE    50

int main(int argc, char* argv[])
{
	int retval;

	// 명령행 인수가 있으면 IP 주소로 사용
	if (argc > 1) SERVERIP = argv[1];

	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	// connect() 호출에 사용할 변수
	struct sockaddr_in serveraddr;
	memset(&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	inet_pton(AF_INET, SERVERIP, &serveraddr.sin_addr);
	serveraddr.sin_port = htons(SERVERPORT);

	// 데이터 통신에 사용할 변수
	char buf[BUFSIZE];
	const char* testdata[] = {
		"안녕하세요",
		"반가워요",
		"오늘따라 할 이야기가 많을 것 같네요",
		"저도 그렇네요",
	};
	int len;

	// 서버와 데이터 통신
	for (int i = 0; i < 4; i++) {
		// 소켓 생성
		SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock == INVALID_SOCKET) err_quit("socket()");

		// connect()
		retval = connect(sock, (struct sockaddr*)&serveraddr, sizeof(serveraddr));
		if (retval == SOCKET_ERROR) err_quit("connect()");

		// 데이터 입력(시뮬레이션)
		len = (int)strlen(testdata[i]);
		strncpy(buf, testdata[i], len);

		// 데이터 보내기
		retval = send(sock, buf, len, 0);
		if (retval == SOCKET_ERROR) {
			err_display("send()");
			break;
		}
		printf("[TCP 클라이언트] %d바이트를 보냈습니다.\n", retval);

		// 소켓 닫기
		closesocket(sock);
	}

	// 윈속 종료
	WSACleanup();
	return 0;
}

```

- 서버 코드 : TCPServer_CloseOnTransfer

```jsx
#include "..\Common.h"

#define SERVERPORT 9000
#define BUFSIZE    1024

int main(int argc, char* argv[])
{
	int retval;

	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	// 소켓 생성
	SOCKET listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (listen_sock == INVALID_SOCKET) err_quit("socket()");

	// bind()
	struct sockaddr_in serveraddr;
	memset(&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(SERVERPORT);
	retval = bind(listen_sock, (struct sockaddr*)&serveraddr, sizeof(serveraddr));
	if (retval == SOCKET_ERROR) err_quit("bind()");

	// listen()
	retval = listen(listen_sock, SOMAXCONN);
	if (retval == SOCKET_ERROR) err_quit("listen()");

	// 데이터 통신에 사용할 변수
	SOCKET client_sock;
	struct sockaddr_in clientaddr;
	int addrlen;
	char buf[BUFSIZE + 1];

	while (1) {
		// accept()
		addrlen = sizeof(clientaddr);
		client_sock = accept(listen_sock, (struct sockaddr*)&clientaddr, &addrlen);
		if (client_sock == INVALID_SOCKET) {
			err_display("accept()");
			break;
		}

		// 접속한 클라이언트 정보 출력
		char addr[INET_ADDRSTRLEN];
		inet_ntop(AF_INET, &clientaddr.sin_addr, addr, sizeof(addr));
		printf("\n[TCP 서버] 클라이언트 접속: IP 주소=%s, 포트 번호=%d\n",
			addr, ntohs(clientaddr.sin_port));

		// 클라이언트와 데이터 통신
		while (1) {
			// 데이터 받기
			retval = recv(client_sock, buf, BUFSIZE, MSG_WAITALL);
			if (retval == SOCKET_ERROR) {
				err_display("recv()");
				break;
			}
			else if (retval == 0)
				break;

			// 받은 데이터 출력
			buf[retval] = '\0';
			printf("[TCP/%s:%d] %s\n", addr, ntohs(clientaddr.sin_port), buf);
		}

		// 소켓 닫기
		closesocket(client_sock);
		printf("[TCP 서버] 클라이언트 종료: IP 주소=%s, 포트 번호=%d\n",
			addr, ntohs(clientaddr.sin_port));
	}

	// 소켓 닫기
	closesocket(listen_sock);

	// 윈속 종료
	WSACleanup();
	return 0;
}

```

- 서버  화면

![image.png](data8.png)

- 클라이언트 화면

![image.png](data9.png)

- 데이터 전송 후 종료 서버 코드 구성
    - 접속한 클라이언트 정보 출력
    - 클라이언트와 데이터 통신
        - 데이터 받기
        - 받은 데이터 출력
    - 클라이언트 소켓 닫기
    - 고정 길이 데이터 전송 서버 코드와 동일
    
- 고정 길이 데이터 전송 서버
    - 접속한 클라이언트 정보 출력
    - 클라이언트와 데이터 통신
        - 데이터 받기
        - 받은 데이터 출력
    - 클라이언트 소켓 닫기

### 데이터 전송 후 종료 서버의 장 단점 (TCP 구조상)

- 장점 : 데이터 오버헤드가 발생하지 않음
    - 보낼 데이터의 바이트 개수 만큼만 보내고, 더 이상의 데이터 오버헤드는 발생되지 않음
- 단점 : 컨트롤 오버헤드의 발생
    - 아래 그림과 같이 클라이언트가 서버에 접속하기 위해서는 connect() 함수를 클라이언트에서 사용해야 하고, 서버에서는 accept()함수로 응대하여야 한다.
    - connect()함수를 사용하기 전에 서버까지의 경로 파악이 우선되어야 하기 때문에 TCP 3-Way Handshake가 선행된다.
    - 그리고 connect() 가 완료되면 서버는 클라이언트의 IP 주소와 Port 번호를 알게 되며 accept() 함수를 이용하여 새로운 client_socket을 생성한다.
    - 클라이언트가 send() 함수로 데이터를 전송하고, 그 이후에 소켓이 종료 될 때, TCP 4-Way Handshake가 진행된다.
    - 따라서 데이터를 보낼 때마다 새로운 클라이언트 소켓이 생성되기 위해 필요한 TCP 3-Way Handshake 컨트롤 오버헤드가 발생하고, 데이터 전송이 끝난 후 소켓이 종료 될 때, TCP 4-Way Handshake 컨트롤 오버헤드가 발생한다.
- 보낸 데이터가 n 건이면 n*TCP 3-Way Handshake, n*TCP 4-Way Handshake 컨트롤 오버헤드가 발생한다.
- 이는 곧 라우터에 부담을 주게 되며 네트워크 자원을 낭비하게 되는 원인이 된다.

![image.png](data10.png)

![image.png](data11.png)

### 전송방법에 따른 장 단점 비교

| 전송 방법 | 장점 | 단점 |
| --- | --- | --- |
| 고정길이 데이터 전송 | 컨트롤 오버헤드 발생하지 않음 | 데이터 오버헤드 발생 |
| 가변길이 데이터 전송 | 데이터 오버헤드 발생하지 않음 | 프로그래밍 복잡도 상승 (recv() API 함수의 재사용성이 떨어짐） |
| 고정길이+가변길이 데이터 전송 | 컨트롤 오버헤드 발생하지 않음 | 데이터 오버헤드 발생 |
| 전송 후 종료 서버 | 데이터 오버헤드 발생하지 않음 | 컨트롤 오버헤드 발생 (동일한 클라이언트 소켓을 사용하지 않음) |

### 고정길이 데이터 전송 장단점

- 장점
    - 컨트롤 오버헤드가 발생하지 않음
    - 동일한 클라이언트 소켓을 사용하므로,
        - TCP 3-Way Handshake, TCP 4-Way Handshake 컨트롤 오버헤드가 발생하지 않음
- 단점
    - 데이터 오버헤드가 발생함
    - 보낼 데이터의 바이트 개수 이상의 데이터 오버헤드가 발생함

### 가변길이 데이터 전송 장단점

- 장점 : 데이터 오버헤드가 발생하지 않음
    - 보낼 데이터의 바이트 개수 이상의 데이터 오버헤드가 발생하지 않음
    - 동일한 클라이언트 소켓을 사용하므로, TCP 3-Way Handshake, TCP 4-Way Handshake 컨트롤 오버헤드가 발생하지 않음
- 단점 : 데이터 오버헤드가 발생함
    - recv() API 함수의 재사용성이 떨어짐
    - recv() API 함수 이외에 수신 데이터 바이트 전송을 위한 추가적인 API 함수(recv_line()과 recv_ahead() 함수 등)를 필요로 하는 개발 비용 증가

### 고정길이+가변길이 데이터 전송 장단점

- 장점 : 컨트롤 오버헤드가 발생하지 않음
    - send() 함수를 두 번 사용하지만,
    - 동일한 클라이언트 소켓을 사용하므로,
    - TCP 3-Way Handshake, TCP 4-Way Handshake 컨트롤 오버헤드가 발생하지 않음
- 단점 : 데이터 오버헤드가 발생함
    - 보낼 데이터의 바이트 개수 이상의 데이터 오버헤드가 발생함

### 데이터 전송 후 종료 서버의 장 단점 (TCP 구조상)

- 장점 : 데이터 오버헤드가 발생하지 않음
    - 보낼 데이터의 바이트 개수 만큼만 보내고, 더 이상의 데이터 오버헤드는 발생되지 않음
- 단점 : 컨트롤 오버헤드의 발생
    - 아래 그림과 같이 클라이언트가 서버에 접속하기 위해서는 connect() 함수를 클라이언트에서 사용해야 하고, 서버에서는 accept()함수로 응대하여야 한다.
    - connect()함수를 사용하기 전에 서버까지의 경로 파악이 우선되어야 하기 때문에 TCP 3-Way Handshake가 선행된다.
    - 그리고 connect() 가 완료되면 서버는 클라이언트의 IP 주소와 Port 번호를 알게 되며 accept() 함수를 이용하여 새로운 client_socket을 생성한다.
    - 클라이언트가 send() 함수로 데이터를 전송하고, 그 이후에 소켓이 종료 될 때, TCP 4-Way Handshake가 진행된다.
    - 따라서 데이터를 보낼 때마다 새로운 클라이언트 소켓이 생성되기 위해 필요한 TCP 3-Way Handshake 컨트롤 오버헤드가 발생하고, 데이터 전송이 끝난 후 소켓이 종료 될 때, TCP 4-Way Handshake 컨트롤 오버헤드가 발생한다.
- 보낸 데이터가 n 건이면 n*TCP 3-Way Handshake, n*TCP 4-Way Handshake 컨트롤 오버헤드가 발생한다.
- 이는 곧 라우터에 부담을 주게 되며 네트워크 자원을 낭비하게 되는 원인이 된다.
